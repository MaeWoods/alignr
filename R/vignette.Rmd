---
title: "Citeseq surface demultiplexing with aocseq"
output: rmarkdown::html_vignette
bibliography: references.bib  
author: Noah Crooks and Mae Woods
vignette: >
  %\VignetteIndexEntry{vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width=6,fig.height=3
)
```

## Citeseq and cell surface labelling
Data that has been multiplexed with Hash Tagged Oligos (HTOs - see https://www.10xgenomics.com/analysis-guides/demultiplexing-and-analyzing-5%E2%80%99-immune-profiling-libraries-pooled-with-hashtags.) and cell surface protein antibody oligos can be analyzed with aocseq. 

These data are imported similarly to immuno-profiling data, but an additional step is added, such that cells are assigned to groups based on their hashtag counts, with probabilities generated by the GMM Demux algorithm [@GMMDEMUX]. This example demonstrates how single cells can be labelled by their samples, receptors and or surface protein expression after demultiplexing.

## Install Required Packages
Aocseq is compatible with other cell analysis packages, including Seurat [@Seurat] and Single Cell Experiment [@SCE]. In contrast to other packages, the purpose of aocseq is to 

**1.** provide a sample list of mixed cell types with accompanying datasheets and 

**2.** Develop methods to score and rank cells based on optimal characteristics. 

To accomplish this, genes of interest (GOIs) are defined prior to dimension reduction. These are genes that depend on the conditions of the experiment, are ubiquitously expressed and characterize cell types (of any frequency) e.g. clonotypes, receptor sequences and cell phenotypes. In this example, it will be demonstrated how GOIs can be used for metadata to subset cells after dimension reduction, even if a particular GOI is not included in the variable genes that define the **latent space**, highlighting aocseq's purpose to display and analyze low frequency cellular subtypes. 

To begin load the required packages.

```{r, warning=FALSE}
library(aocseq)
library(Seurat)
library(ggplot2)
library(ggpubr)
library(circlize)
```

## Importing Data
Data import is handled by the CombineData function. For this vignette, the data used is from the paper "Chimeric Antigen Receptor-induced Antigen Loss Protects CD5.CART Cells From Fratricide Without Compromising On-target Cytotoxicity" [@metal]. These data contain 13278 T cells that have been co-cultured with CD5.CART cells from 3 healthy donors. The scRNA sequencing in this study was used to understand the transcriptional and cell phenotypic changes that occur in healthy T cells as a result of co-culture with CAR T cells that are directed toward a surface protein that is expressed on the surface of a T cell. The data can be downloaded from zenodo. Before running CombineData, open terminal and make a file system Citeseq_Example, then download the example data and unzip the compressed files. 

```{bash, eval = F}
cd ~/Documents

mkdir Citeseq_Example

cd Citeseq_Example

WKDIR=~/Documents/Citeseq_Example

mkdir Data, RDS, DataSheet, Figures

curl -O "https://zenodo.org/records/11286440/files/Figures-Rscripts.zip?download=1"

gunzip Figures-Rscripts.zip

cd Figures-Rscripts/Data

cp -r CD5 ${WKDIR}/Data
```

The raw data consists of cell hashing and gene expression transcripts in 10X genomics feature barcode format. There are 6 input variables to CombineData. **gex.path** - the location of the feature barcode files, **marker.gene** - these are the GOIs, this example will show that CCL1 is expressed in donor 2 and 3 only and that, despite not being included as a variable feature, it can still be displayed with the dimension reduction. **save.dir** - this is the location to store a Seurat Object after demultiplexing. **my.demultiplex.index** - these are the surface values that you would like to run demultiplexing on, these hashtagged samples can be given names and in this example we call them **my.names.hashtags**. In this example, the first 7 slots in the antibody capture are surface protein and so we will not be demultiplexing these data. Finally, **my.n.ht.per.sample** is the number of hashtags used per sequencing run.

```{r}
gex.path=c("~/Documents/Citeseq_Example/SeqData/CD5")
marker.gene=c("IFNG","CD5","GZMB","CCR7","CCL1","CD28","CD27")
save.dir="~/Documents/Citeseq_Example/RDS/CD5.rds"
my.demultiplex.index = c(8, 9, 10)
my.names.hashtags = c('donor_1', 'donor_2','donor_3')
my.n.ht.per.sample = 3
```

Using these inputs, CombineData will create a list of Seurat objects, one for each sample/hashtag combination. CombineData can perform QC filtering based on the nFeature_RNA_lower, nFeature_RNA_upper, and percent.mt_upper parameters. These parameters represent the lower and upper cutoffs for RNA feature counts, and the upper bound for mitochondrial RNA percentage, respectively. If set, these parameters produce figures with lines that show the cutoff and cells that are excluded. To speed up the example, we have set nvariable_features=500 but this can take any value and the default is 3000.

```{r}
CellData=CombineData(gex.path,
                     marker.gene,
                     file.saved=save.dir,
                     demultiplex=TRUE,
                     demultiplex.index=my.demultiplex.index,
                     nameshashtags=my.names.hashtags,
                     n.ht.per.sample = my.n.ht.per.sample,
                     nvariable_features=500,
                     QC_plots = TRUE)
```

Running CombineData will output the raw counts per sample and QC values. It will also provide a list of Seurat objects. In this case, we have three Seurat objects, one for each hashtag. As seen in the output from running the function CombineData, the GOI CCL1 was not included in Seurat's sctransformed data and therefore it is not included in the variable features used for dimension reduction. Despite this, cells that express CCL1 can be subset in the data and displayed on a 2D UMAP embedding.

```{r, warning=FALSE}
my.ident.list=c("orig.ident")
my.save.dir="~/Documents/Citeseq_Example/Figures"
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width=4,fig.height=4
)
```

```{r, warning=FALSE}
UMAPReduce(
  CellData[[2]],
  save.dir=my.save.dir,
  ident.list=my.ident.list
)
```

The next three plots split the UMAP by the different subsets of cells annotated by the GOIs CCl1, CD5 and GZMB

```{r, warning=FALSE}
my.ident.list=c("Threshold_CCL1","Threshold_CD5","Threshold_GZMB")
my.save.dir="~/Documents/Citeseq_Example/Figures"
```

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width=5,fig.height=3
)
```

```{r, warning=FALSE}
par(mfrow = c(2, 2))
UMAPReduce(
  CellData[[2]],
  save.dir=my.save.dir,
  ident.list=my.ident.list
)
```

## Multimodal summary datasheets

In addition to using GMM demux for hashtag demultiplexing, aocseq can also be used to label cell phenotypes by their surface antibody expression. This example will use the function AnnotateCellTypes to produce a summary data sheet that can then be used to visualize the differences in frequency of the cell types across the three donors with the function SegmentPlot. 

To begin this example, define a cell type based on surface expression. The cells are labelled with CD4, CD8, CD62L and CD5 surface markers. So, the data will be split in to **1)** CD4+ CD5 high CD62L high **2)** CD4+ CD5 high CD62L low **3)** CD4+ CD5 low CD62L high  **4)** CD4+ CD5 low CD62L low **5)** CD8+ CD5 high CD62L high **6)** CD8+ CD5 high CD62L low **7)** CD8+ CD5 low CD62L high  **8)** CD8+ CD5 low CD62L low

This time, GMM_demux can be called with the CellData that has been generated to split the cells into their CD4 and CD8 subsets, since the expression of surface CD5 and and CD62L was not bimodal, the cell types were further split by the upper quantile of surface antibody counts.

```{r,warning=FALSE}
for(k in 1:3){
  CellData[[k]] <- GMM_demux(my.names.hashtags[k],CellData[[k]], c(1,2),c("CD4","CD8"),set.col.name="MHC",Seurat_Object = TRUE)
  ncells=dim(CellData[[k]])[2]
  celltypes=c(as.character(1:8),"unassigned")
  CD5Counts=CellData[[k]]@assays$HTO@counts[3,]
  CD62LCounts=CellData[[k]]@assays$HTO@counts[7,]
  MHC=CellData[[k]]@meta.data$MHC
  CD5_high=unname(quantile(CD5Counts,.75))
  CD62L_high=unname(quantile(CD62LCounts,.75))
  cell_types=rep("unassigned",ncells)
  cell_types[unname(which(MHC=="CD4" & CD5Counts>CD5_high & CD62LCounts>CD62L_high))]=celltypes[1]
  cell_types[unname(which(MHC=="CD4" & CD5Counts>CD5_high & CD62LCounts<CD62L_high))]=celltypes[2]
  cell_types[unname(which(MHC=="CD4" & CD5Counts<CD5_high & CD62LCounts>CD62L_high))]=celltypes[3]
  cell_types[unname(which(MHC=="CD4" & CD5Counts<CD5_high & CD62LCounts>CD62L_high))]=celltypes[4]
  cell_types[unname(which(MHC=="CD8" & CD5Counts>CD5_high & CD62LCounts>CD62L_high))]=celltypes[5]
  cell_types[unname(which(MHC=="CD8" & CD5Counts>CD5_high & CD62LCounts<CD62L_high))]=celltypes[6]
  cell_types[unname(which(MHC=="CD8" & CD5Counts<CD5_high & CD62LCounts>CD62L_high))]=celltypes[7]
  cell_types[unname(which(MHC=="CD8" & CD5Counts<CD5_high & CD62LCounts<CD62L_high))]=celltypes[8]
  CellData[[k]]=AddMetaData(CellData[[k]],cell_types,col.name="cell_types")
  
  countcln=rep(0,ncells)
  countcln[unname(which(CellData[[k]]@meta.data$cell_types=="1"))]=length(unname(which(CellData[[k]]@meta.data$cell_types=="1")))
  countcln[unname(which(CellData[[k]]@meta.data$cell_types=="2"))]=length(unname(which(CellData[[k]]@meta.data$cell_types=="2")))
  countcln[unname(which(CellData[[k]]@meta.data$cell_types=="3"))]=length(unname(which(CellData[[k]]@meta.data$cell_types=="3")))
  countcln[unname(which(CellData[[k]]@meta.data$cell_types=="4"))]=length(unname(which(CellData[[k]]@meta.data$cell_types=="4")))
  countcln[unname(which(CellData[[k]]@meta.data$cell_types=="5"))]=length(unname(which(CellData[[k]]@meta.data$cell_types=="5")))
  countcln[unname(which(CellData[[k]]@meta.data$cell_types=="6"))]=length(unname(which(CellData[[k]]@meta.data$cell_types=="6")))
  countcln[unname(which(CellData[[k]]@meta.data$cell_types=="7"))]=length(unname(which(CellData[[k]]@meta.data$cell_types=="7")))
  countcln[unname(which(CellData[[k]]@meta.data$cell_types=="8"))]=length(unname(which(CellData[[k]]@meta.data$cell_types=="8")))
  CellData[[k]]=AddMetaData(CellData[[k]],countcln,col.name="countcln")
  
  Threshold_CD4=rep("unassigned",ncells)
  Threshold_CD4[unname(which(CellData[[k]]@meta.data$CD4cells=="1"))]="high"
  CellData[[k]]=AddMetaData(CellData[[k]],Threshold_CD4,col.name="Threshold_CD4")
  Threshold_CD8=rep("unassigned",ncells)
  Threshold_CD8[unname(which(CellData[[k]]@meta.data$CD8cells=="1"))]="high"
  CellData[[k]]=AddMetaData(CellData[[k]],Threshold_CD8,col.name="Threshold_CD8A")
}
```

The function CombineData is designed to work with a control and perturbation to assign GOIs with "high" and "unassigned" annotation. In this example, we would like to see if CD5 mRNA is still expressed during surface CD5 downregulation. So lets set the CD5 GOI values again using the upper quantile per donor sample.

```{r,warning=FALSE}
for(k in 1:3){
  ncells=dim(CellData[[k]])[2]
CD5p=match("CD5",row.names(CellData[[k]]@assays$RNA@counts))
CD5t=unname(quantile(CellData[[k]]@assays$RNA@counts[CD5p,],.75))
Threshold_CD5=rep("unassigned",ncells)
Threshold_CD5[unname(which(CellData[[k]]@assays$RNA@counts[CD5p,]>CD5t))]="high"
CellData[[k]]@meta.data$Threshold_CD5=Threshold_CD5
}
```

Now metadata has been added, AnnotateCellTypes can be run and this function will produce summary data sheets of the cell types and GOIs. The example below creates a Summary data sheet for the genes CD4, CD8A and CD5. We should see perfect overlap between the surface citeseq and mRNA.

```{r,warning=FALSE}
CD4DataSheet=AnnotateCellTypes(CellData,goi="CD4",names.spreadsheet=c("donor1","donor2","donor3"),path="~/Documents/Citeseq_Example/DataSheet/",TCR = FALSE,cellType = "cell_types")
CD8DataSheet=AnnotateCellTypes(CellData,goi="CD8A",names.spreadsheet=c("donor1","donor2","donor3"),path="~/Documents/Citeseq_Example/DataSheet/",TCR = FALSE,cellType = "cell_types")
CD5DataSheet=AnnotateCellTypes(CellData,goi="CD5",names.spreadsheet=c("donor1","donor2","donor3"),path="~/Documents/Citeseq_Example/DataSheet/",TCR = FALSE,cellType = "cell_types")
```
The Summary data sheet for the CD4+ cell types is displayed below. Each cell type is listed in the first column and the percentage of cells that make up that cell type for the cells labelled by their mRNA expression of CD4 mRNA transcripts is listed for all three donors. In this table you can see that the percentage of cells with abundance CD4 mRNA transcripts is concordant with the high expression on the surface labeling. 

```{r,warning=FALSE}
CD4DataSheet
```

The number of cells in each cell type is also included in the summary tables and the average number of cells per type is ordered by size and in the column avg. Now these tables can be used to plot the proportion of the cell types shared between the donors. Although there was insufficient capture of surface protein to conclude on the effect of CD5.CAR T cells on healthy resting T cells by comparative analysis between donors, the sharing of the high and low frequency phenotypes across all donors suggests the cells that survive co-culture have similar phenotypes.

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width=7,fig.height=4
)
```

```{r,warning=FALSE}
par(mfrow = c(1, 3))

my.summarydf=read.csv("~/Documents/Citeseq_Example/DataSheet/CD5/SummaryTable.csv")
my.names=c("donor1.Cells","donor2.Cells")
my.segment.names=c("donor1.Cells","donor2.Cells")
n.segments=7
tune.gap=3
segmentPlot(my.summarydf,names=my.names,segment.names=my.segment.names,n.segments=7,tune.gap=3,segment.names.spacer="23mm",percentage.spacer.1="8mm",percentage.spacer.2="8mm",segment.col=c("green","red"))

my.summarydf=read.csv("~/Documents/Citeseq_Example/DataSheet/CD5/SummaryTable.csv")
my.names=c("donor1.Cells","donor3.Cells")
my.segment.names=c("donor1.Cells","donor3.Cells")
n.segments=7
tune.gap=3
segmentPlot(my.summarydf,names=my.names,segment.names=my.segment.names,n.segments=7,tune.gap=3,segment.names.spacer="23mm",percentage.spacer.1="8mm",percentage.spacer.2="8mm")

my.summarydf=read.csv("~/Documents/Citeseq_Example/DataSheet/CD5/SummaryTable.csv")
my.names=c("donor2.Cells","donor3.Cells")
my.segment.names=c("donor2.Cells","donor3.Cells")
n.segments=7
tune.gap=3
segmentPlot(my.summarydf,names=my.names,segment.names=my.segment.names,n.segments=7,tune.gap=3,segment.names.spacer="23mm",percentage.spacer.1="8mm",percentage.spacer.2="8mm",segment.col=c("red","blue"))

```

## References

<div id="refs"></div>

